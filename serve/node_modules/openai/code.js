"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
Object.defineProperty(exports, "__esModule", { value: true });
exports.isObj = exports.toBase64 = exports.getHeader = exports.getRequiredHeader = exports.isHeadersProtocol = exports.isRunningInBrowser = exports.debug = exports.hasOwn = exports.isEmptyObj = exports.maybeCoerceBoolean = exports.maybeCoerceFloat = exports.maybeCoerceInteger = exports.coerceBoolean = exports.coerceFloat = exports.coerceInteger = exports.readEnv = exports.ensurePresent = exports.castToError = exports.sleep = exports.safeJSON = exports.isRequestOptions = exports.createResponseHeaders = exports.PagePromise = exports.AbstractPage = exports.APIClient = exports.APIPromise = exports.createForm = exports.multipartFormRequestOptions = exports.maybeMultipartFormRequestOptions = void 0;
const version_1 = require("./version.js");
const streaming_1 = require("./streaming.js");
const error_1 = require("./error.js");
const index_1 = require("./_shims/index.js");
const uploads_1 = require("./uploads.js");
var uploads_2 = require("./uploads.js");
Object.defineProperty(exports, "maybeMultipartFormRequestOptions", { enumerable: true, get: function () { return uploads_2.maybeMultipartFormRequestOptions; } });
Object.defineProperty(exports, "multipartFormRequestOptions", { enumerable: true, get: function () { return uploads_2.multipartFormRequestOptions; } });
Object.defineProperty(exports, "createForm", { enumerable: true, get: function () { return uploads_2.createForm; } });
async function defaultParseResponse(props) {
    const { response } = props;
    if (props.options.stream) {
        debug('response', response.status, response.url, response.headers, response.body);
        if (props.options.__streamClass) {
            return props.options.__streamClass.fromSSEResponse(response, props.controller);
        }
        return streaming_1.Stream.fromSSEResponse(response, props.controller);
    }
    if (response.status === 204) {
        return null;
    }
    if (props.options.__binaryResponse) {
        return response;
    }
    const contentType = response.headers.get('content-type');
    const isJSON = (contentType && contentType.includes('application/json')) || (contentType && contentType.includes('application/vnd.api+json'));
    if (isJSON) {
        const json = await response.json();
        debug('response', response.status, response.url, response.headers, json);
        return _addRequestID(json, response);
    }
    const text = await response.text();
    debug('response', response.status, response.url, response.headers, text);
    return text;
}
function _addRequestID(value, response) {
    if (!value || typeof value !== 'object' || Array.isArray(value)) {
        return value;
    }
    return Object.defineProperty(value, '_request_id', {
        value: response.headers.get('x-request-id'),
        enumerable: false,
    });
}
/**
 * A subclass of `Promise` providing additional helper methods
 * for interacting with the SDK.
 */
class APIPromise extends Promise {
    constructor(responsePromise, parseResponse = defaultParseResponse) {
        super((resolve) => {
            resolve(null);
        });
        this.responsePromise = responsePromise;
        this.parseResponse = parseResponse;
    }
    _thenUnwrap(transform) {
        return new APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));
    }
    asResponse() {
        return this.responsePromise.then((p) => p.response);
    }
    async withResponse() {
        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
        return { data, response, request_id: response.headers.get('x-request-id') };
    }
    parse() {
        if (!this.parsedPromise) {
            this.parsedPromise = this.responsePromise.then(this.parseResponse);
        }
        return this.parsedPromise;
    }
    then(onfulfilled, onrejected) {
        return this.parse().then(onfulfilled, onrejected);
    }
    catch(onrejected) {
        return this.parse().catch(onrejected);
    }
    finally(onfinally) {
        return this.parse().finally(onfinally);
    }
}
exports.APIPromise = APIPromise;
class APIClient {
    constructor({ baseURL, maxRetries = 2, timeout = 600000, httpAgent, fetch: overridenFetch }) {
        this.baseURL = baseURL;
        this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);
        this.timeout = validatePositiveInteger('timeout', timeout);
        this.httpAgent = httpAgent;
        this.fetch = overridenFetch || index_1.fetch;
    }
    authHeaders(opts) {
        return {};
    }
    defaultHeaders(opts) {
        return {
            Accept: 'application/json',
            'Content-Type': 'application/json',
            'User-Agent': this.getUserAgent(),
            ...getPlatformHeaders(),
            ...this.authHeaders(opts),
        };
    }
    validateHeaders(headers, customHeaders) { }
    defaultIdempotencyKey() {
        return `stainless-node-retry-${uuid4()}`;
    }
    get(path, opts) {
        return this.methodRequest('get', path, opts);
    }
    post(path, opts) {
        return this.methodRequest('post', path, opts);
    }
    patch(path, opts) {
        return this.methodRequest('patch', path, opts);
    }
    put(path, opts) {
        return this.methodRequest('put', path, opts);
    }
    delete(path, opts) {
        return this.methodRequest('delete', path, opts);
    }
    methodRequest(method, path, opts) {
        return this.request(Promise.resolve(opts).then(async (opts) => {
            const body = opts && uploads_1.isBlobLike(opts.body) ? new DataView(await opts.body.arrayBuffer())
                : opts && opts.body instanceof DataView ? opts.body
                    : opts && opts.body instanceof ArrayBuffer ? new DataView(opts.body)
                        : opts && ArrayBuffer.isView(opts.body) ? new DataView(opts.body.buffer)
                            : opts.body;
            return { method, path, ...opts, body };
        }));
    }
    getAPIList(path, Page, opts) {
        return this.requestAPIList(Page, { method: 'get', path, ...opts });
    }
    calculateContentLength(body) {
        if (typeof body === 'string') {
            if (typeof Buffer !== 'undefined') {
                return Buffer.byteLength(body, 'utf8').toString();
            }
            if (typeof TextEncoder !== 'undefined') {
                const encoder = new TextEncoder();
                const encoded = encoder.encode(body);
                return encoded.length.toString();
            }
        }
        else if (ArrayBuffer.isView(body)) {
            return body.byteLength.toString();
        }
        return null;
    }
    buildRequest(options, { retryCount = 0 } = {}) {
        const { method, path, query, headers = {} } = options;
        const body = ArrayBuffer.isView(options.body) || (options.__binaryRequest && typeof options.body === 'string') ?
            options.body
            : uploads_1.isMultipartBody(options.body) ? options.body.body
                : options.body ? JSON.stringify(options.body, null, 2)
                    : null;
        const contentLength = this.calculateContentLength(body);
        const url = this.buildURL(path, query);
        if ('timeout' in options)
            validatePositiveInteger('timeout', options.timeout);
        const timeout = options.timeout || this.timeout;
        const httpAgent = options.httpAgent || this.httpAgent || index_1.getDefaultAgent(url);
        const minAgentTimeout = timeout + 1000;
        if (httpAgent && httpAgent.options && typeof httpAgent.options.timeout === 'number' &&
            minAgentTimeout > (httpAgent.options.timeout || 0)) {
            httpAgent.options.timeout = minAgentTimeout;
        }
        if (this.idempotencyHeader && method !== 'get') {
            if (!options.idempotencyKey)
                options.idempotencyKey = this.defaultIdempotencyKey();
            headers[this.idempotencyHeader] = options.idempotencyKey;
        }
        const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
        const req = {
            method,
            ...(body && { body: body }),
            headers: reqHeaders,
            ...(httpAgent && { agent: httpAgent }),
            signal: options.signal || null,
        };
        return { req, url, timeout };
    }
    buildHeaders({ options, headers, contentLength, retryCount, }) {
        const reqHeaders = {};
        if (contentLength) {
            reqHeaders['content-length'] = contentLength;
        }
        const defaultHeaders = this.defaultHeaders(options);
        applyHeadersMut(reqHeaders, defaultHeaders);
        applyHeadersMut(reqHeaders, headers);
        if (uploads_1.isMultipartBody(options.body) && index_1.kind !== 'node') {
            delete reqHeaders['content-type'];
        }
        if (getHeader(headers, 'x-stainless-retry-count') === undefined) {
            reqHeaders['x-stainless-retry-count'] = String(retryCount);
        }
        this.validateHeaders(reqHeaders, headers);
        return reqHeaders;
    }
    async prepareOptions(options) { }
    async prepareRequest(request, { url, options }) { }
    parseHeaders(headers) {
        return (!headers ? {}
            : Symbol.iterator in headers ?
                Object.fromEntries(Array.from(headers).map((header) => [...header]))
                : { ...headers });
    }
    makeStatusError(status, error, message, headers) {
        return error_1.APIError.generate(status, error, message, headers);
    }
    request(options, remainingRetries = null) {
        return new APIPromise(this.makeRequest(options, remainingRetries));
    }
    async makeRequest(optionsInput, retriesRemaining) {
        const options = await optionsInput;
        const maxRetries = options.maxRetries || this.maxRetries;
        if (retriesRemaining == null) {
            retriesRemaining = maxRetries;
        }
        await this.prepareOptions(options);
        const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
        await this.prepareRequest(req, { url, options });
        debug('request', url, options, req.headers);
        if (options.signal && options.signal.aborted) {
            throw new error_1.APIUserAbortError();
        }
        const controller = new AbortController();
        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
        if (response instanceof Error) {
            if (options.signal && options.signal.aborted) {
                throw new error_1.APIUserAbortError();
            }
            if (retriesRemaining) {
                return this.retryRequest(options, retriesRemaining);
            }
            if (response.name === 'AbortError') {
                throw new error_1.APIConnectionTimeoutError();
            }
            throw new error_1.APIConnectionError({ cause: response });
        }
        const responseHeaders = createResponseHeaders(response.headers);
        if (!response.ok) {
            if (retriesRemaining && this.shouldRetry(response)) {
                const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
                debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders);
                return this.retryRequest(options, retriesRemaining, responseHeaders);
            }
            const errText = await response.text().catch((e) => castToError(e).message);
            const errJSON = safeJSON(errText);
            const errMessage = errJSON ? undefined : errText;
            const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
            debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
            const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
            throw err;
        }
        return { response, options, controller };
    }
    requestAPIList(Page, options) {
        const request = this.makeRequest(options, null);
        return new PagePromise(this, request, Page);
    }
    buildURL(path, query) {
        const url = isAbsoluteURL(path) ?
            new URL(path)
            : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));
        const defaultQuery = this.defaultQuery();
        if (!isEmptyObj(defaultQuery)) {
            query = { ...defaultQuery, ...query };
        }
        if (typeof query === 'object' && query && !Array.isArray(query)) {
            url.search = this.stringifyQuery(query);
        }
        return url.toString();
    }
    stringifyQuery(query) {
        return Object.entries(query)
            .filter(([_, value]) => typeof value !== 'undefined')
            .map(([key, value]) => {
            if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
                return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
            }
            if (value === null) {
                return `${encodeURIComponent(key)}=`;
            }
            throw new error_1.OpenAI.RequestError({ message: `Cannot encode object value for key: ${key}` });
        })
            .join('&');
    }
    retryRequest(options, retriesRemaining, headers) {
        if (options.signal && options.signal.aborted) {
            throw new error_1.APIUserAbortError();
        }
        return new APIPromise(this.makeRequest(options, retriesRemaining - 1), async () => {
            throw new error_1.APIRateLimitError({ message: 'Retries exhausted', headers });
        });
    }
    shouldRetry(response) {
        return response.status >= 500;
    }
    async fetchWithTimeout(url, req, timeout, controller) {
        const timer = setTimeout(() => controller.abort(), timeout);
        try {
            return await this.fetch(url, { ...req, signal: controller.signal });
        }
        finally {
            clearTimeout(timer);
        }
    }
    async getUserAgentInfo() {
        const baseAgent = this.getUserAgent();
        const platformAgent = await getPlatformHeaders();
        return { baseAgent, platformAgent };
    }
    getUserAgent() {
        return `stainless-js/${version_1.PKG_VERSION}`;
    }
    defaultQuery() {
        return {};
    }
    async requestEventData(request) {
        const { baseAgent, platformAgent } = await this.getUserAgentInfo();
        return {
            client: this.getUserAgent(),
            ...platformAgent,
            ...baseAgent,
            ...request,
        };
    }
    buildResponseEventData(props) {
        const { response, options } = props;
        return {
            client: this.getUserAgent(),
            status: response.status,
            response: {
                headers: props.response.headers,
                body: props.response.body,
            },
            request: options,
            url: props.url,
            headers: props.headers,
        };
    }
}
exports.APIClient = APIClient;
/**
 * AbstractPage provides shared methods for API response pages
 * and implements a data cursor.
 */
class AbstractPage {
    constructor(client, responsePromise, Page) {
        _AbstractPage_client.set(this, void 0);
        __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
        this.responsePromise = responsePromise;
        this.Page = Page;
    }
    _response() {
        return this.responsePromise.then(async (props) => {
            return await props.controller();
        });
    }
}
_AbstractPage_client = new WeakMap();
exports.AbstractPage = AbstractPage;
async function sleep(ms) {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
}
exports.sleep = sleep;
async function castToError(e) {
    if (e instanceof Error) {
        return e;
    }
    return new Error(`${e}`);
}
exports.castToError = castToError;
function ensurePresent(value, message) {
    if (value === undefined || value === null) {
        throw new Error(message);
    }
    return value;
}
exports.ensurePresent = ensurePresent;
function readEnv(envName) {
    return process.env[envName];
}
exports.readEnv = readEnv;
function coerceInteger(v) {
    return parseInt(v, 10);
}
exports.coerceInteger = coerceInteger;
function coerceFloat(v) {
    return parseFloat(v);
}
exports.coerceFloat = coerceFloat;
function coerceBoolean(v) {
    return v.toLowerCase() === 'true';
}
exports.coerceBoolean = coerceBoolean;
function maybeCoerceInteger(v) {
    if (v === undefined || v === null) {
        return undefined;
    }
    return coerceInteger(v);
}
exports.maybeCoerceInteger = maybeCoerceInteger;
function maybeCoerceFloat(v) {
    if (v === undefined || v === null) {
        return undefined;
    }
    return coerceFloat(v);
}
exports.maybeCoerceFloat = maybeCoerceFloat;
function maybeCoerceBoolean(v) {
    if (v === undefined || v === null) {
        return undefined;
    }
    return coerceBoolean(v);
}
exports.maybeCoerceBoolean = maybeCoerceBoolean;
function isEmptyObj(obj) {
    return !Object.keys(obj).length;
}
exports.isEmptyObj = isEmptyObj;
function hasOwn(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
exports.hasOwn = hasOwn;
function debug(...args) {
    if (process.env.NODE_DEBUG === 'true') {
        console.log(...args);
    }
}
exports.debug = debug;
function isRunningInBrowser() {
    return typeof window !== 'undefined' && typeof window.document !== 'undefined';
}
exports.isRunningInBrowser = isRunningInBrowser;
function isHeadersProtocol(protocol) {
    return protocol === 'http:' || protocol === 'https:';
}
exports.isHeadersProtocol = isHeadersProtocol;
function getRequiredHeader(headers, key) {
    const value = getHeader(headers, key);
    if (!value) {
        throw new error_1.APIConnectionError({
            message: `Missing required header ${key}`,
        });
    }
    return value;
}
exports.getRequiredHeader = getRequiredHeader;
function getHeader(headers, key) {
    if (!headers) {
        return undefined;
    }
    return headers instanceof Map
        ? headers.get(key)
        : hasOwn(headers, key)
            ? headers[key]
            : undefined;
}
exports.getHeader = getHeader;
function toBase64(input) {
    return Buffer.from(input).toString('base64');
}
exports.toBase64 = toBase64;
function isObj(o) {
    return typeof o === 'object' && o !== null && !Array.isArray(o);
}
exports.isObj = isObj;

